
This tutorial is licensed under the MIT License (MIT).

```julia
println("Number of threads: $(Base.Threads.nthreads())")
```

```julia
using Plots; pyplot();
```

```julia
# Load required Julia packages:

using ArraysOfArrays, StaticArrays, Tables, TypedTables
using Statistics, Random, Distributions, StatsBase
using Unitful
import HDF5

using SolidStateDetectors
using RadiationSpectra
using RadiationDetectorSignals
using RadiationDetectorSignals: group_by_evtno, ungroup_by_evtno, group_by_evtno_and_detno
using LegendDataTypes
using LegendHDF5IO: readdata, writedata
using LegendTextIO
```

<h1 style="text-align: center">
    LEGEND Software Stack Tutorial in <br/>
    <img alt="Julia" src="images/logos/julia-logo.svg" style="height: 2em; display: inline-block; margin: 1em;"/>
</h1>

<p style="text-align: center">
    Lukas&nbsp;Hauertmann&nbsp;&lang;<a href="mailto:lhauert@mpp.mpg.de" target="_blank">lhauert@mpp.mpg.de</a>&rang;,
    Oliver&nbsp;Schulz&nbsp;&lang;<a href="mailto:oschulz@mpp.mpg.de" target="_blank">oschulz@mpp.mpg.de</a>&rang;,
    Martin&nbsp;Schuster&nbsp;&lang;<a href="mailto:schuster@mpp.mpg.de" target="_blank">schuster@mpp.mpg.de</a>&rang;,
    Anna&nbsp;Julia&nbsp;Zsigmond&nbsp;&lang;<a href="azsigmon@mpp.mpg.de" target="_blank">azsigmon@mpp.mpg.de</a>&rang;
</p>

<div style="margin-top:1em">
    <p style="text-align: center">
        <img alt="LEGEND Logo" src="images/logos/legend-logo.svg" style="height: 10em; display: inline-block; margin: 1em;"/>
    </p>
</div>

<p>See <a href="README.md">README.md</a> for instructions.</p>

## Calculation of detector potentials and fields

### Detector definition

First, load a detector definition - here, an inverted-coaxial example detector design:

```julia
detector_config_filename = SSD_examples[:InvertedCoax]
T = Float32 # Optional; Default is Float32, but works with Float64 as well
detector = SolidStateDetector{T}(detector_config_filename)
S = SSD.get_coordinate_system(detector)
plot(detector)
```

Now the collection structure `setup::SSDSetup` should be initialized. It will hold all the different fields of the simulation (e.g. electric potential, weighting potentials, ...)

```julia
setup = SSDSetup(detector);
```

One can also have a look at how the initial conditions look like on the grid (its starts with a very coarse grid):

```julia
SSD.apply_initial_state!(setup) # optional 
plot(plot(setup.electric_potential), plot(setup.point_types), plot(setup.ρ), plot(setup.ϵ), layout = (1, 4), size = (1400, 700))
```

Next, calculate the electric potential:

```julia
SSD.calculate_electric_potential!(setup, max_refinements = 4)
```

```julia
plot(plot(setup.electric_potential), plot(setup.point_types), plot(setup.ρ), plot(setup.ϵ), layout = (1, 4), size = (1400, 700))
```

SolidStateDetectors.jl supports active (i.e. depleted) volume calculation:

```julia
get_active_volume(setup.point_types)
```

### Partially depleted detectors

SolidStateDetectors.jl can also calculate the electric potential of a partially depleted detector:

```julia
detector_undep = deepcopy(detector)
detector_undep.contacts[end].potential = 500; # V  <-- Bias Voltage
```

```julia
detector_undep.contacts[end].potential
```

```julia
setup_undep = SSDSetup(detector_undep);
SSD.calculate_electric_potential!(setup_undep, depletion_handling = true, convergence_limit=1e-6, max_refinements = 4, verbose = false);
```

```julia
plot(plot(setup_undep.electric_potential), plot(setup_undep.point_types), layout = (1, 2), size = (800, 700))
```

### Electric field calculation

Calculate the electric field of the fully depleted detector, given the already calculated electric potential:

```julia
SSD.calculate_electric_field!(setup, n_points_in_φ = 72) # SSD.calculate_electric_field!(setup, n_points_in_φ = 72)
```

```julia
# plot(E_field, detector, E_pot, φ = 0, spacing = 0.001f0, n_steps = 2000) #, detector, E_pot)
# plot!(detector, :plane, φ = 0)
```

### Drift field calculation

Given the electric field and a charge drift model, calculate drift fields for electrons and holes. Precalculating the drift fields saves time during charge drift simulation:

```julia
drift_model = ADLChargeDriftModel()
SSD.set_charge_drift_model!(setup, drift_model)
```

And apply the charge drift model to the electric field:

```julia
SSD.apply_charge_drift_model!(setup)
```

Now, let's create an "random" event:

```julia
starting_positions = [CylindricalPoint{T}( 0.02, deg2rad(10), 0.015 ), CylindricalPoint{T}( 0.015, deg2rad(20), 0.045 ), CylindricalPoint{T}( 0.025, deg2rad(30), 0.025 )]
energy_depos = T[1460, 609, 1000] * u"keV" # they are needed later in the signal generation

event = SSD.Event(starting_positions, energy_depos);
```

```julia
SSD.drift_charges!(event, setup)
```

```julia
plot(setup.detector)
plot!(event.drift_paths)
```

### Weighting potential calculation

We need weighting potentials to simulate the detector charge signal induced by drifting charges. We'll calculate the weighting potential for the point contact and the outer shell of the detector:

```julia
n_contacts = length(setup.detector.contacts)
for contact in setup.detector.contacts
    SSD.calculate_weighting_potential!(setup, contact.id, max_refinements = 4, n_points_in_φ = 2, verbose = false)
end
```

```julia
p_Wpot_1 = plot(  setup.weighting_potentials[1].itp.knots[1], 
                  setup.weighting_potentials[1].itp.knots[3], 
                  setup.weighting_potentials[1].itp.coefs[:, 1, :]', 
                  st = :heatmap, aspect_ratio = 1 , clims=(0, 1))
p_Wpot_2 = plot(  setup.weighting_potentials[2].itp.knots[1], 
                  setup.weighting_potentials[2].itp.knots[3], 
                  setup.weighting_potentials[2].itp.coefs[:, 1, :]', 
                  st = :heatmap, aspect_ratio = 1 , clims=(0, 1))
p = plot(p_Wpot_1, p_Wpot_2)
```

## Detector waveform generation

### Single-event simulation

Given an interaction at an arbitrary point in the detector, we can now simulate charge drift and the resulting detector charge signals (e.g. at the point contact):

```julia
SSD.get_signal!(event, setup, 1) # 1 = contact id of the point contact, 2 would be the mantle (defined in the config file)
```

```julia
p_pc_signal = plot(event.signals[1], lw = 1.5, xlims = (0, 1300))
```

Or just calculate the signals of all channels:

```julia
SSD.get_signals!(event, setup) 
p_pc_signal = plot(event.signals, lw = 1.5, xlims = (0, 1300))
```

The drift ans signal generation can also be done together:

```julia
SSD.simulate!(event, setup)
```

### Waveform generation for Geant4 MC events

Let's read in some Monte-Carlo events (produced by Geant4). We'll either read from Geant4 CSV and cache the result as HDF5, or read directly from HDF5 if already available:

```julia
mctruth_filename_csv = joinpath("data", "dual-invcoax-mctruth.csv")
mctruth_filename_hdf5 = joinpath("cache", "dual-invcoax-mctruth.h5")
if isfile(mctruth_filename_hdf5)
    println("Reading MC events from HDF5.")
    mc_events = HDF5.h5open(mctruth_filename_hdf5, "r") do input
        readdata(input, "mctruth")
    end
else
    println("Reading MC events from Geant4-CSV.")
    mc_events = open(read, mctruth_filename_csv, Geant4CSVInput)
    mkpath(dirname(mctruth_filename_hdf5))
    println("Writing MC events to HDF5.")
    HDF5.h5open(mctruth_filename_hdf5, "w") do output
        writedata(output, "mctruth", mc_events)
    end
end
```

Producing pulse shapes from raw MC events is wastful, it's more efficient to cluster detectors hits (within a small radius) first:

```julia
println("$(sum(length.(mc_events.edep))) hits before clustering")
mc_events_clustered = @time cluster_detector_hits(mc_events, 0.2u"mm")
println("$(sum(length.(mc_events_clustered.edep))) hits after clustering")
```

Table of MC events is of type `DetectorHitEvents`:

```julia
typeof(mc_events_clustered) <: DetectorHitEvents
```

We have a plotting reciple for `DetectorHitEvents`:

```julia
plot(mc_events_clustered)
```

Waveform generation has to be per detector. Let's reshuffle the detector hits, grouping by event number and detector:

```julia
hits = ungroup_by_evtno(mc_events_clustered)
mc_events_per_det = group_by_evtno_and_detno(hits)
```

The hits are now grouped by event number, but separately for each detector, and sorted by detector number:

```julia
issorted(mc_events_per_det.detno)
```

This makes it easy to group them by detector number ...

```julia
mc_events_by_det = Table(consgroupedview(mc_events_per_det.detno, Tables.columns(mc_events_per_det)))
```

... and get all events for detector 1 in one chunk:

```julia
mc_events_det1 = Table(mc_events_by_det[1])
```

```julia
plot(mc_events_det1)
```

Raw MC events have a very narrow line width:

```julia
stephist(ustrip.(sum.(mc_events_det1.edep)), bins = 2600:0.1:2625, yscale = :log10)
```

Let's make things more realistic by adding Fano noise:

```julia
det_material = detector.material_detector
mc_events_fnoise = add_fano_noise(mc_events_det1, det_material.E_ionisation, det_material.f_fano)
stephist(ustrip.(sum.(mc_events_det1.edep)), bins = 2600:0.1:2625, label = "raw MC edep", yscale = :log10)
stephist!(ustrip.(sum.(mc_events_fnoise.edep)), bins = 2600:0.1:2625, label = "with Fano noise", yscale = :log10)
```

Also, we need to filter out the few events that, due to numerical effects, lie outside of the detector (the proper solution is to shift them slightly, this feature will be added in the future):

```julia
filtered_events = mc_events_fnoise[findall(pts -> all(p -> p in detector, pts), mc_events_fnoise.pos)];
length(filtered_events)
```

```julia
in(SSD.CylindricalPoint(SSD.CartesianPoint(SSD.to_internal_units(u"m", filtered_events.pos[1][1]))), detector)
```

```julia
contact_charge_signals = @time generate_charge_signals( setup, filtered_events, n_steps = 256, Δt = 10u"ns", verbose = false);
```

```julia
typeof(filtered_events.pos)
```

Let's plot the first 100 generated waveforms:

```julia
waveforms = contact_charge_signals[1]
plot(waveforms[1:100], legend = false)
```

```julia
evt1 = SSD.Event(filtered_events[findmin([minimum(wf) for wf in waveforms[1:100]])[2]], T)
# @show evt1.locations
SSD.simulate!(evt1, setup, n_steps = 200, Δt = 10u"ns", verbose = true)
p_drift = plot(setup.detector)
plot!(evt1.drift_paths[1])
p_signal = plot(evt1.signals)
plot(p_drift, p_signal, size = (1200, 600))
```

We should add pre- and post-pulse baselines ...

```julia
waveforms_with_baseline = nestedview(vcat(fill!(similar(flatview(waveforms)), 0), flatview(waveforms)))
plot(waveforms_with_baseline[1:100], legend = false)
```

... and also add some random values along the waveforms to simulate electronics noise in a simple fashion:

```julia
noise = rand!(Normal(0,5e3), similar(flatview(waveforms_with_baseline)))
noisy_waveforms = nestedview(flatview(waveforms_with_baseline) .+ noise)
plot(noisy_waveforms[1:100], legend = false)
```

## Waveform DSP

Note: This section only demonstrates a very simple form of DSP for energy reconstruction, and will be extended in the near future.

We can reconstruct a spectrum from the simulated waveforms, using the difference between the pre- and post-pulse baseline means energy of the events (equivalent to a triangular shaping filter in a fixed position):

```julia
filter_length = 20
pre_pulse_mean = vec(mean(flatview(noisy_waveforms)[1:filter_length, :], dims = 1))
post_pulse_mean = vec(mean(flatview(noisy_waveforms)[end-filter_length:end, :], dims = 1))
E_reco = post_pulse_mean .- pre_pulse_mean
hist_uncal = fit(Histogram, E_reco, nbins = 10000)
plot(hist_uncal, st = :step, yscale = :log10, label="uncalibrated spectrum")
```

## Spectrum analysis

The package RadiationSpectra.jl provides a mechanism finding peaks in the spectrum. It can also auto-calibration of the spectrum, given a list of gamma lines that may be in the spectrum:

```julia
gamma_lines = [510.77, 583.191, 2614.533] 
h_cal, h_deconv, peakPositions, threshold, c, c_precal = RadiationSpectra.calibrate_spectrum(hist_uncal, gamma_lines) #, min_n_peaks = 10, α = 0.1, rtol = 0.1)
p_deconv = plot(h_deconv, st=:step, label = "uncalibrated spectrum", tickfontsize = 12, legendfontsize = 12)
hline!([threshold], label ="threshold")
p_cal = plot(h_cal, st = :step, yscale = :log10, label="calibrated spectrum", xlabel="E / keV", xlims=[0, 3000], xticks=0:500:3000, tickfontsize = 12, legendfontsize = 12, guidefontsize = 14)
vline!(gamma_lines, label="gamma lines: $(gamma_lines)")
plot(p_deconv, p_cal, layout = (2,1), size = (1000, 700))
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```
