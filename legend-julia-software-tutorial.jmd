
This tutorial is licensed under the MIT License (MIT).

```julia
println("Number of threads: $(Base.Threads.nthreads())")
```

```julia
using Plots; pyplot();
```

```julia
# Load required Julia packages:

using ArraysOfArrays, StaticArrays, Tables, TypedTables
using Statistics, Random, Distributions, StatsBase
using Unitful
import HDF5

using SolidStateDetectors
using RadiationSpectra
using RadiationDetectorSignals
using RadiationDetectorSignals: group_by_evtno, ungroup_by_evtno, group_by_evtno_and_detno
using LegendDataTypes
using LegendHDF5IO: readdata, writedata
using LegendTextIO
```

<h1 style="text-align: center">
    LEGEND Software Stack Tutorial in <br/>
    <img alt="Julia" src="images/logos/julia-logo.svg" style="height: 2em; display: inline-block; margin: 1em;"/>
</h1>

<p style="text-align: center">
    Lukas&nbsp;Hauertmann&nbsp;&lang;<a href="mailto:lhauert@mpp.mpg.de" target="_blank">lhauert@mpp.mpg.de</a>&rang;,
    Oliver&nbsp;Schulz&nbsp;&lang;<a href="mailto:oschulz@mpp.mpg.de" target="_blank">oschulz@mpp.mpg.de</a>&rang;,
    Martin&nbsp;Schuster&nbsp;&lang;<a href="mailto:schuster@mpp.mpg.de" target="_blank">schuster@mpp.mpg.de</a>&rang;,
    Anna&nbsp;Julia&nbsp;Zsigmond&nbsp;&lang;<a href="azsigmon@mpp.mpg.de" target="_blank">azsigmon@mpp.mpg.de</a>&rang;
</p>

<div style="margin-top:1em">
    <p style="text-align: center">
        <img alt="LEGEND Logo" src="images/logos/legend-logo.svg" style="height: 10em; display: inline-block; margin: 1em;"/>
    </p>
</div>

<p>See <a href="README.md">README.md</a> for instructions.</p>

## Calculation of detector potentials and fields

### Detector definition

First, load a detector definition - here, an inverted-coaxial example detector design:

```julia
detector_config_filename = SSD_examples[:InvertedCoax]
T = Float32 # Optional; Default is Float32, but works with Float64 as well
simulation = Simulation{T}(detector_config_filename)
plot(simulation.detector, size = (700, 700))
```

One can also have a look at how the initial conditions look like on the grid (its starts with a very coarse grid):

```julia
SSD.apply_initial_state!(simulation) # optional 
plot(
    plot(simulation.electric_potential), # initial electric potential (boundary conditions)
    plot(simulation.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted
    plot(simulation.ρ), # charge density distribution
    plot(simulation.ϵ), # dielectric distribution
    layout = (1, 4), size = (1400, 700)
)
```

Next, calculate the electric potential:

```julia
SSD.calculate_electric_potential!(simulation, max_refinements = 4)
```

```julia
plot(
    plot(simulation.electric_potential, φ = 20), # initial electric potential (boundary conditions)
    plot(simulation.point_types), # map of different point types: fixed point / inside or outside detector volume / depleted/undepleted
    plot(simulation.ρ), # charge density distribution
    plot(simulation.ϵ), # dielectric distribution
    layout = (1, 4), size = (1400, 700)
)
```

SolidStateDetectors.jl supports active (i.e. depleted) volume calculation:

```julia
get_active_volume(simulation.point_types) # approximation (sum of the volume of cells marked as depleted)
```

### Partially depleted detectors

SolidStateDetectors.jl can also calculate the electric potential of a partially depleted detector:

```julia
detector_undep = deepcopy(simulation.detector)
detector_undep.contacts[end].potential = 200; # V  <-- Bias Voltage
```

```julia
simulation_undep = Simulation(detector_undep);
SSD.calculate_electric_potential!(simulation_undep, depletion_handling = true, convergence_limit=1e-6, max_refinements = 4, verbose = false);
```

```julia
plot(
    plot(simulation_undep.electric_potential), 
    plot(simulation_undep.point_types), 
    layout = (1, 2), size = (800, 700)
)
```

```julia
println("Depleted: ", get_active_volume(simulation.point_types))
println("Depleted: ", get_active_volume(simulation_undep.point_types));
```

### Electric field calculation

Calculate the electric field of the fully depleted detector, given the already calculated electric potential:

```julia
SSD.calculate_electric_field!(simulation, n_points_in_φ = 72)
```

```julia
plot_electric_field(simulation, φ = 0)
```

### Drift field calculation

Given the electric field and a charge drift model, calculate drift fields for electrons and holes. Precalculating the drift fields saves time during charge drift simulation:

```julia
drift_model = ADLChargeDriftModel()
SSD.set_charge_drift_model!(simulation, drift_model)
```

And apply the charge drift model to the electric field:

```julia
SSD.apply_charge_drift_model!(simulation)
```

Now, let's create an "random" (multiside) event:

```julia
starting_positions = [CylindricalPoint{T}( 0.02, deg2rad(10), 0.015 ), CylindricalPoint{T}( 0.015, deg2rad(20), 0.045 ), CylindricalPoint{T}( 0.025, deg2rad(30), 0.025 )]
energy_depos = T[1460, 609, 1000] * u"keV" # they are needed later in the signal generation

event = SSD.Event(starting_positions, energy_depos);
```

```julia
time_step = 5u"ns"
SSD.drift_charges!(event, simulation, Δt = time_step)
```

```julia
plot(simulation.detector, size = (700, 700))
plot!(event.drift_paths)
```

### Weighting potential calculation

We need weighting potentials to simulate the detector charge signal induced by drifting charges. We'll calculate the weighting potential for the point contact and the outer shell of the detector:

```julia
for contact in simulation.detector.contacts
    SSD.calculate_weighting_potential!(simulation, contact.id, max_refinements = 4, n_points_in_φ = 2, verbose = false)
end
```

```julia
plot(  
    plot(simulation.weighting_potentials[1]),
    plot(simulation.weighting_potentials[2]),
    size = (900, 700)
)
```

# I/O

The package offeres a conversion of all the calculated fields to `NamedTuple`'s
which allows for saving and loading them into HDF5 files via the LegendHDF5 package:

```julia
simulation
```

```julia
filename = "cache/inverted_coax_simulation.h5f"
if !ispath(dirname(filename)) mkpath(dirname(filename)) end
HDF5.h5open(filename, "w") do h5f
    writedata( h5f, "inverted_coax_simulation", NamedTuple(simulation)  )
end
```

```julia
simulation = HDF5.h5open(filename, "r") do h5f
    Simulation(readdata(h5f, "inverted_coax_simulation"));
end;
SSD.set_charge_drift_model!(simulation, ADLChargeDriftModel())
```

```julia
simulation
```

# Quick Simulation

```julia
quick_sim = Simulation(detector_config_filename)
simulate!(quick_sim); # Keywords (defaults):  max_refinements = 1, verbose = false
plot( 
    plot(quick_sim.electric_potential),
    plot(quick_sim.weighting_potentials[1]),
    plot(quick_sim.weighting_potentials[2]),
    size = (1200, 500), layout = (1, 3)
)
```

## Detector waveform generation

### Single-event simulation

Given an interaction at an arbitrary point in the detector, we can now simulate charge drift and the resulting detector charge signals (e.g. at the point contact):

```julia
SSD.get_signal!(event, simulation, 1) # 1 = contact id of the point contact, 2 would be the mantle (defined in the config file)
```

```julia
time_steps = range(0, step = ustrip(time_step), length = length(event.signals[1]))
p_pc_signal = plot( time_steps, event.signals[1], lw = 1.5, xlims = (0, 2000), xlabel = "Time / ns", legend = false, tickfontsize = 12, ylabel = "Energy / eV", guidefontsize = 14)
```

Or just calculate the signals of all channels:

```julia
SSD.get_signals!(event, simulation) 
plot(  time_steps, event.signals[1], lw = 1.5, xlims = (0, 2000), xlabel = "Time / ns", legend = false, tickfontsize = 12, ylabel = "Energy / eV", guidefontsize = 14)
plot!( time_steps, event.signals[2], lw = 1.5)
```

The drift and signal generation can also be done together:

```julia
SSD.simulate!(event, simulation) # drift_charges + signal generation of all channels
```

### Waveform generation for Geant4 MC events

Let's read in some Monte-Carlo events (produced by Geant4). We'll either read from Geant4 CSV and cache the result as HDF5, or read directly from HDF5 if already available:

```julia
mctruth_filename_csv = joinpath("data", "dual-invcoax-mctruth.csv")
mctruth_filename_hdf5 = joinpath("cache", "dual-invcoax-mctruth.h5")
if isfile(mctruth_filename_hdf5)
    println("Reading MC events from HDF5.")
    mc_events = HDF5.h5open(mctruth_filename_hdf5, "r") do input
        readdata(input, "mctruth")
    end
else
    println("Reading MC events from Geant4-CSV.")
    mc_events = open(read, mctruth_filename_csv, Geant4CSVInput)
    mkpath(dirname(mctruth_filename_hdf5))
    println("Writing MC events to HDF5.")
    HDF5.h5open(mctruth_filename_hdf5, "w") do output
        writedata(output, "mctruth", mc_events)
    end
end
```

Producing pulse shapes from raw MC events is wastful, it's more efficient to cluster detectors hits (within a small radius) first:

```julia
println("$(sum(length.(mc_events.edep))) hits before clustering")
mc_events_clustered = @time cluster_detector_hits(mc_events, 0.2u"mm")
println("$(sum(length.(mc_events_clustered.edep))) hits after clustering")
```

Table of MC events is of type `DetectorHitEvents`:

```julia
typeof(mc_events_clustered) <: DetectorHitEvents
```

We have a plotting reciple for `DetectorHitEvents`:

```julia
plot(mc_events_clustered)
```

Waveform generation has to be per detector. Let's reshuffle the detector hits, grouping by event number and detector:

```julia
hits = ungroup_by_evtno(mc_events_clustered)
mc_events_per_det = group_by_evtno_and_detno(hits)
```

The hits are now grouped by event number, but separately for each detector, and sorted by detector number:

```julia
issorted(mc_events_per_det.detno)
```

This makes it easy to group them by detector number ...

```julia
mc_events_by_det = Table(consgroupedview(mc_events_per_det.detno, Tables.columns(mc_events_per_det)))
```

... and get all events for detector 1 in one chunk:

```julia
mc_events_det1 = Table(mc_events_by_det[1])
```

```julia
plot(mc_events_det1)
```

Raw MC events have a very narrow line width:

```julia
stephist(ustrip.(sum.(mc_events_det1.edep)), bins = 2600:0.1:2625, yscale = :log10)
```

Let's make things more realistic by adding Fano noise:

```julia
det_material = simulation.detector.semiconductors[1].material
mc_events_fnoise = add_fano_noise(mc_events_det1, det_material.E_ionisation, det_material.f_fano)
stephist(ustrip.(sum.(mc_events_det1.edep)), bins = 2600:0.1:2625, label = "raw MC edep", yscale = :log10)
stephist!(ustrip.(sum.(mc_events_fnoise.edep)), bins = 2600:0.1:2625, label = "with Fano noise", yscale = :log10)
```

Also, we need to filter out the few events that, due to numerical effects, lie outside of the detector (the proper solution is to shift them slightly, this feature will be added in the future):

```julia
filtered_events = mc_events_fnoise[findall(pts -> all(p -> p in simulation.detector, pts), mc_events_fnoise.pos)];
length(filtered_events)
```

```julia
in(SSD.CylindricalPoint(SSD.CartesianPoint(SSD.to_internal_units(u"m", filtered_events.pos[1][1]))), simulation.detector)
```

```julia
contact_charge_signals = generate_charge_signals( simulation, filtered_events[1:2000], n_steps = 256, Δt = 20u"ns", verbose = false);
```

Let's plot the first 100 generated waveforms:

```julia
waveforms = contact_charge_signals[1]
plot(waveforms[1:100], legend = false)
```

```julia
evt1 = SSD.Event(filtered_events[1], T)
SSD.simulate!(evt1, simulation, n_steps = 2000, Δt = 10u"ns", verbose = true)
p_drift = plot(simulation.detector)
plot!(evt1.drift_paths)
p_signal = plot(evt1.signals)
plot(p_drift, p_signal, size = (1200, 600))
```

We should add pre- and post-pulse baselines ...

```julia
waveforms_with_baseline = nestedview(vcat(fill!(similar(flatview(waveforms)), 0), flatview(waveforms)))
plot(waveforms_with_baseline[1:100], legend = false)
```

... and also add some random values along the waveforms to simulate electronics noise in a simple fashion:

```julia
noise = rand!(Normal(0,5e3), similar(flatview(waveforms_with_baseline)))
noisy_waveforms = nestedview(flatview(waveforms_with_baseline) .+ noise)
plot(noisy_waveforms[1:100], legend = false)
```

## Waveform DSP

Note: This section only demonstrates a very simple form of DSP for energy reconstruction, and will be extended in the near future.

We can reconstruct a spectrum from the simulated waveforms, using the difference between the pre- and post-pulse baseline means energy of the events (equivalent to a triangular shaping filter in a fixed position):

```julia
filter_length = 50
pre_pulse_mean = vec(mean(flatview(noisy_waveforms)[1:filter_length, :], dims = 1))
post_pulse_mean = vec(mean(flatview(noisy_waveforms)[end-filter_length:end, :], dims = 1))
E_reco = post_pulse_mean .- pre_pulse_mean
hist_uncal = fit(Histogram, E_reco, nbins = 2000)
plot(hist_uncal, st = :step, yscale = :log10, label="uncalibrated spectrum")
```

## Spectrum analysis

The package RadiationSpectra.jl provides a mechanism finding peaks in the spectrum. It can also auto-calibration of the spectrum, given a list of gamma lines that may be in the spectrum:

```julia
gamma_lines = [510.77, 583.191, 2614.533] 
h_cal, h_deconv, peakPositions, threshold, c, c_precal = RadiationSpectra.calibrate_spectrum(hist_uncal, gamma_lines, threshold = 0.5, σ = 1) #, min_n_peaks = 10, α = 0.1, rtol = 0.1)
p_uncal = plot(hist_uncal, st=:step, label = "uncalibrated spectrum", tickfontsize = 12, legendfontsize = 12)
p_deconv = plot(h_deconv, st=:step, label = "deconvoluted spectrum", tickfontsize = 12, legendfontsize = 12)
hline!([threshold], label ="threshold")
p_cal = plot(h_cal, st = :step, yscale = :log10, label="calibrated spectrum", xlabel="E / keV", xlims=[0, 3000], xticks=0:500:3000, tickfontsize = 12, legendfontsize = 12, guidefontsize = 14)
vline!(gamma_lines, label="gamma lines: $(gamma_lines)")
plot(p_uncal, p_deconv, p_cal, layout = (3,1), size = (1000, 700))
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```

```julia
```
